<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Josh Werts]]></title>
  <link href="http://joshwerts.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://joshwerts.com/"/>
  <updated>2015-04-13T10:41:58-04:00</updated>
  <id>http://joshwerts.com/</id>
  <author>
    <name><![CDATA[Josh Werts]]></name>
    <email><![CDATA[joshwerts@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Debugging Server Object Extensions (SOEs) in Style]]></title>
    <link href="http://joshwerts.com/blog/2015/04/12/debugging-server-object-extensions-soe-in-style/"/>
    <updated>2015-04-12T17:09:42-04:00</updated>
    <id>http://joshwerts.com/blog/2015/04/12/debugging-server-object-extensions-soe-in-style</id>
    <content type="html"><![CDATA[<p>Server Object Extensions (SOEs) can be incredibly powerful, but they can also be a pain to debug.</p>

<h4>Typical workflow:</h4>

<ol>
<li>Rebuild solution</li>
<li>Open ArcGIS Manager in browser &ndash;> Site &ndash;> Extensions &ndash;> Update Extension by selecting .soe file.</li>
<li>Restart all of the services that depended on the SOE.</li>
<li>Attach Visual Studio to process.</li>
</ol>


<p>Steps 2 &amp; 3 are the really annoying ones, but they can be automated!</p>

<p>It turns out this is really a post about REST and Python.</p>

<p>When you update an SOE through the ArcGIS Manager app (<a href="http://localhost/arcgis/manager">http://localhost/arcgis/manager</a>), the web application is actually making calls to ArcGIS Server REST admin endpoints.</p>

<h3>Automate with Python</h3>

<p>I&rsquo;ll cut to the chase.</p>

<p><strong>See the full script here:</strong><br/>
<a href="https://github.com/jwerts/soe-updater">https://github.com/jwerts/soe-updater</a></p>

<p>Usage (simply run from command line after rebuilding SOE solution):
```
C:\Projects_General_Code\soe-updater>python update_soe.py</p>

<p>Retrieving token&hellip;
Retrieved: oUK04q-J8ORWDUrSWGPfq8zAU29u3q5_YZ79ZvcFZx8kFneOMb5Z2Y2Yf19
Uploading SOE&hellip;
Uploaded: ibd792bae-a986-4861-8ac3-c16d42f4d610
Updating SOE&hellip;
Updated!
Starting services&hellip;
Starting service_folder/service.MapServer
Started!
```</p>

<p>Your SOE will be updated and services restarted.  You can re-attach to the service processes or if you&rsquo;re using <code>System.Diagnostics.Debugger.Launch();</code> in your <code>Init()</code> function, you&rsquo;ll automatically be greeted with the dialog to attach your process once the script finishes and the services restart.</p>

<br/><br/>


<p>Now a little explanation of what&rsquo;s going on&hellip;</p>

<h3>REST API Calls</h3>

<h4>Generate token</h4>

<p>Because we&rsquo;re going to automate this, we need a preliminary step.  We&rsquo;ll generate a token that can be passed to subsequent steps.
<code>
http://localhost/arcgis/rest/tokens
</code></p>

<h4>Upload the SOE</h4>

<p>The .soe file that gets generated after building in Visual Studio is uploaded to ArcGIS Server and returns an itemID.
<code>
http://localhost/arcgis/admin/uploads/upload
</code></p>

<h4>Update the SOE</h4>

<p>Another call references the uploaded .soe through the itemID and updates the extension.
<code>
http://localhost/arcgis/admin/services/types/extensions/update
</code></p>

<h4>Restart services</h4>

<p>After the SOE is updated, all services that use it are stopped and must be restarted.  This can also be accomplished through REST calls:
<code>
http://localhost/arcgis/admin/services/[service_folder]/[service_name]/start
</code></p>

<p>These calls are all pretty straightford to automate in a Python script using the requests library (<a href="http://docs.python-requests.org/en/latest/">http://docs.python-requests.org/en/latest/</a>).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[arcpy.da Cursors and Readability Part 2]]></title>
    <link href="http://joshwerts.com/blog/2014/12/21/arcpy-dot-da-cursors-and-readability-part-2/"/>
    <updated>2014-12-21T16:36:33-05:00</updated>
    <id>http://joshwerts.com/blog/2014/12/21/arcpy-dot-da-cursors-and-readability-part-2</id>
    <content type="html"><![CDATA[<p>arcpy.da cursors provide the simplest data structure by default (tuples).  Python generators provide a pretty neat way of customizing these cursors to increase readability.</p>

<h3>SearchCursor:</h3>

<p><strong>Return <code>dict</code> instead of tuple:</strong>
```python
def rows_as_dicts(cursor):
  &ldquo;&rdquo;&ldquo; returns rows as dicts (does not maintain field order) &rdquo;&ldquo;&rdquo;
  colnames = cursor.fields
  for row in cursor:</p>

<pre><code>yield dict(zip(colnames, row))
</code></pre>

<p>```</p>

<p><strong>Usage</strong> (note the cursor is wrapped with the generator):
```python
total_cost_by_name = {}
with arcpy.da.SearchCursor(costs_table, [&ldquo;name&rdquo;, &ldquo;unit_cost&rdquo;, &ldquo;quantity&rdquo;]) as curs:
  for row in rows_as_dicts(curs):</p>

<pre><code>total_cost_by_name[row["name"]] = row["unit_cost"] * row["quantity"]
</code></pre>

<p>```</p>

<p>If using with an update cursor, you&rsquo;ll want to use an OrderedDict so the field/value order is maintained.  You&rsquo;ll also need to the use <code>dict.values()</code> to pass an ordered tuple back into Cursor.updateRow.</p>

<h3>UpdateCursor:</h3>

<p><strong>Return <code>collections.OrderedDict</code> instead of tuple:</strong></p>

<p>```python
import collections
def rows_as_ordered_dicts(cursor):
  &ldquo;&rdquo;&ldquo; returns rows as collections.OrderedDict &rdquo;&ldquo;&rdquo;
  colnames = cursor.fields
  for row in cursor:</p>

<pre><code>yield collections.OrderedDict(zip(colnames, row))
</code></pre>

<p>```</p>

<p><strong>Usage</strong> (updating):</p>

<p>```python
with arcpy.da.UpdateCursor(costs_table, [&ldquo;unit_cost&rdquo;, &ldquo;quantity&rdquo;, &ldquo;total_cost&rdquo;]) as curs:
  for row in rows_as_ordered_dicts(curs):</p>

<pre><code>row["total_cost"] = row["unit_cost"] * row["quantity"]

# call .values() to convert back to tuple
# if we didn't use OrderedDict, the values would be in random order.
curs.updateRow( row.values() )
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[arcpy.da Cursors and Readability Part 1]]></title>
    <link href="http://joshwerts.com/blog/2014/08/07/arcpy-dot-da-cursors/"/>
    <updated>2014-08-07T18:36:54-04:00</updated>
    <id>http://joshwerts.com/blog/2014/08/07/arcpy-dot-da-cursors</id>
    <content type="html"><![CDATA[<p>The arcpy.da cursors (ie: arcpy.da.SearchCursor) are far and away better than the regular cursors (ie: arcpy.SearchCursor).  They&rsquo;re more pythonic, incredibly flexible, faster, and allow context management (with).  However, their straight-out-of-the-box-use may be a little hard to read and maintain.</p>

<h3>Fun with Tuples</h3>

<p>arcpy.da cursors return tuples (instead of objects that feel too much like writing ArcObjects).</p>

<h4>Good:</h4>

<p>It&rsquo;s perfectly valid to use tuple indexes to access the fields:</p>

<p>```python
total_cost_by_name = {}
with arcpy.da.SearchCursor(costs_table, [&ldquo;name&rdquo;, &ldquo;unit_cost&rdquo;, &ldquo;quantity&rdquo;]) as curs:</p>

<pre><code>for row in curs:
    total_cost_by_name[row[0]] = row[1] * row[2]
</code></pre>

<p>```</p>

<h4>Better:</h4>

<p>This works fine, but the intent of our calculation is not really clear without some mental mapping.  How about this?
```python
total_cost_by_name = {}
with arcpy.da.SearchCursor(costs_table, [&ldquo;name&rdquo;, &ldquo;unit_cost&rdquo;, &ldquo;quantity&rdquo;]) as curs:</p>

<pre><code>for row in curs:
    name = row[0]
    unit_cost = row[1]
    quantity = row[2]

    total_cost_by_name[name] = unit_cost * quantity
</code></pre>

<p>```</p>

<p>The intent in the calculation is much more clear here, but we&rsquo;ve gained a lot of verbosity that is perhaps unnecessary.</p>

<h4>Best:</h4>

<p>Of course, you could set the variables all on one line <code>name, unit_cost, quantity = row[0], row[1], row[2]</code>, but even better would be to take advantage of python&rsquo;s tuple unpacking:  <code>name, unit_cost, quantity = row</code>.  Taking that one step further, why not unpack every tuple as it&rsquo;s iterated over.  Now we have a process that is both concise and highly readable:</p>

<p>```python
total_cost_by_name = {}
with arcpy.da.SearchCursor(costs_table, [&ldquo;name&rdquo;, &ldquo;unit_cost&rdquo;, &ldquo;quantity&rdquo;]) as curs:</p>

<pre><code>for name, unit_cost, quantity in curs:
    total_cost_by_name[name] = unit_cost * quantity
</code></pre>

<p>```</p>

<p>Now what if we want to update a total cost field in the featureclass using an UpdateCursor instead?</p>

<p>```python
with arcpy.da.UpdateCursor(costs_table, [&ldquo;unit_cost&rdquo;, &ldquo;quantity&rdquo;, &ldquo;total_cost&rdquo;]) as curs:</p>

<pre><code>for unit_cost, quantity, total_cost in curs:
    total_cost = unit_cost * quantity
    curs.updateRow( (unit_cost, quantity, total_cost) )
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python: Recursion With Lists]]></title>
    <link href="http://joshwerts.com/blog/2014/06/28/python-recursion-with-lists/"/>
    <updated>2014-06-28T11:58:45-04:00</updated>
    <id>http://joshwerts.com/blog/2014/06/28/python-recursion-with-lists</id>
    <content type="html"><![CDATA[<p>I rarely find use cases for recursion in my every day work, but every once in a while, there&rsquo;s a problem that comes up where I instantly think: &ldquo;Recursion!&rdquo; (typically followed by an equal mix of excitement and dread).</p>

<p>I often try to get away from GIS related programming when I&rsquo;m not at work.  With limited free time, Python&rsquo;s the perfect language to focus on fundamentals without getting bogged down with other concerns.</p>

<p>Recursion is challenging enough already but I find it even more difficult to wrap my head around when the end result is intended to be a list.  I love nested functions (and closure) in Python (as long as it doesn&rsquo;t get out of hand) and think it works well in this case to provide the expected simple interface to a function despite the fact that recursion is being used internally.</p>

<p>Most of the code I write for work is proprietary and can&rsquo;t be posted here, so here&rsquo;s a classic problem I&rsquo;ve been playing around with simply for learning purposes.</p>

<h4>Code:</h4>

<p>```python
def prime_factors(x):</p>

<pre><code>""" returns all prime factors of x 
ex:  prime_factors(21) = [3,7]
ex:  prime_factors(24) = [2,2,2,3]
"""

def get_first_prime(y):
    """ returns first prime of y """
    # 0 and 1 are not prime, start with 2
    i = 2 

    while i &lt;= y:
        if y % i == 0:
            return i
        i += 1

def get_primes(y, primes):
    """ Recursively appends primes of y
        ex:  prime_factors(24) = [2,2,2,3]

        24
       /  \
      2    12
          /  \
         2    6
             / \
            2   3

    Appends end nodes of tree as it recurses down.
    """
    first_prime = get_first_prime(y)
    primes.append(first_prime)

    if y == first_prime:
        return

    else:
        # Number is not prime and can be divided further.
        # Divide by the first prime (left node) 
        # to get the next test value (right node)
        get_primes(y / first_prime, primes)


primes = []
if x &gt;= 2:
    get_primes(x, primes)

return primes
</code></pre>

<p>```</p>

<h4>Usage:</h4>

<p>```python</p>

<blockquote><blockquote><blockquote><p>prime_factors(24)
[2, 2, 2, 3]
prime_factors(13595)
[5, 7, 13, 29]
prime_factors(23049820394)
[2, 89, 139, 181, 5147]
```</p></blockquote></blockquote></blockquote>

<p>The list <code>primes</code> is passed by reference into the recursive function and simply appended to throughout the operation to keep track of the values.  There is no actual return value from the function.</p>

<p>This could be difficult to follow if the end user used: <code>get_primes(y, primes) -&gt; void</code> directly but since it&rsquo;s wrapped in a simpler interface:  <code>prime_factors(x) -&gt; primes</code>, the end result is a returned list as expected.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arcpy: Reorder Fields]]></title>
    <link href="http://joshwerts.com/blog/2014/04/17/arcpy-reorder-fields/"/>
    <updated>2014-04-17T17:34:45-04:00</updated>
    <id>http://joshwerts.com/blog/2014/04/17/arcpy-reorder-fields</id>
    <content type="html"><![CDATA[<p>Here&rsquo;s another handy function for re-ordering fields in a feature class.  Like the <code>rename_fields</code> function previously posted, it recreates the existing field mappings and modifies as necessary.  The output is a new feature class with fields in the order specified.</p>

<p>The only caveat is that required fields always get pushed to the front (so the featureclass will start with OBJECTID, Shape, rest of fields&hellip;).  After required fields are out of the way, the rest of the fields are added in the order specified in the <code>field_order</code> list.  If any fields are missing, they are added to the end of the feature class.</p>

<p>```python
import arcpy</p>

<p>def reorder_fields(table, out_table, field_order, add_missing=True):</p>

<pre><code>""" 
Reorders fields in input featureclass/table
:table:         input table (fc, table, layer, etc)
:out_table:     output table (fc, table, layer, etc)
:field_order:   order of fields (objectid, shape not necessary)
:add_missing:   add missing fields to end if True (leave out if False)
-&gt; path to output table
"""
existing_fields = arcpy.ListFields(table)
existing_field_names = [field.name for field in existing_fields]

existing_mapping = arcpy.FieldMappings()
existing_mapping.addTable(table)

new_mapping = arcpy.FieldMappings()

def add_mapping(field_name):
    mapping_index = existing_mapping.findFieldMapIndex(field_name)

    # required fields (OBJECTID, etc) will not be in existing mappings
    # they are added automatically
    if mapping_index != -1:
        field_map = existing_mapping.fieldMappings[mapping_index]
        new_mapping.addFieldMap(field_map)

# add user fields from field_order
for field_name in field_order:
    if field_name not in existing_field_names:
        raise Exception("Field: {0} not in {1}".format(field_name, table))

    add_mapping(field_name)

# add missing fields at end
if add_missing:
    missing_fields = [f for f in existing_field_names if f not in field_order]
    for field_name in missing_fields:
        add_mapping(field_name)

# use merge with single input just to use new field_mappings
arcpy.Merge_management(table, out_table, new_mapping)
return out_table
</code></pre>

<p>```</p>

<p>Usage:
<code>python
new_field_order = ["field2", "field3", "field1"]
reorder_fields(in_fc, out_fc, new_field_order)
</code></p>

<p>I&rsquo;ve tested this in 10.1.1+ &ndash; it may work in 10.0 as well and should work with any license level.</p>
]]></content>
  </entry>
  
</feed>
