<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Josh Werts]]></title>
  <link href="http://joshwerts.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://joshwerts.com/"/>
  <updated>2014-12-21T17:05:18-05:00</updated>
  <id>http://joshwerts.com/</id>
  <author>
    <name><![CDATA[Josh Werts]]></name>
    <email><![CDATA[joshwerts@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[arcpy.da Cursors and Readability Part 2]]></title>
    <link href="http://joshwerts.com/blog/2014/12/21/arcpy-dot-da-cursors-and-readability-part-2/"/>
    <updated>2014-12-21T16:36:33-05:00</updated>
    <id>http://joshwerts.com/blog/2014/12/21/arcpy-dot-da-cursors-and-readability-part-2</id>
    <content type="html"><![CDATA[<p>arcpy.da cursors provide the simplest data structure by default (tuples).  Python generators provide a pretty neat way of customizing these cursors to increase readability.</p>

<h3>SearchCursor:</h3>

<p><strong>Return <code>dict</code> instead of tuple:</strong>
```python
def rows_as_dicts(cursor):
  &ldquo;&rdquo;&ldquo; returns rows as dicts (does not maintain field order) &rdquo;&ldquo;&rdquo;
  colnames = cursor.fields
  for row in cursor:</p>

<pre><code>yield dict(zip(colnames, row))
</code></pre>

<p>```</p>

<p><strong>Usage</strong> (note the cursor is wrapped with the generator):
```python
total_cost_by_name = {}
with arcpy.da.SearchCursor(costs_table, [&ldquo;name&rdquo;, &ldquo;unit_cost&rdquo;, &ldquo;quantity&rdquo;]) as curs:
  for row in rows_as_dicts(curs):</p>

<pre><code>total_cost_by_name[row["name"]] = row["unit_cost"] * row["quantity"]
</code></pre>

<p>```</p>

<p>If using with an update cursor, you&rsquo;ll want to use an OrderedDict so the field/value order is maintained.  You&rsquo;ll also need to the use <code>dict.values()</code> to pass an ordered tuple back into Cursor.updateRow.</p>

<h3>UpdateCursor:</h3>

<p><strong>Return <code>collections.OrderedDict</code> instead of tuple:</strong></p>

<p>```python
import collections
def rows_as_ordered_dicts(cursor):
  &ldquo;&rdquo;&ldquo; returns rows as collections.OrderedDict &rdquo;&ldquo;&rdquo;
  colnames = cursor.fields
  for row in cursor:</p>

<pre><code>yield collections.OrderedDict(zip(colnames, row))
</code></pre>

<p>```</p>

<p><strong>Usage</strong> (updating):</p>

<p>```python
with arcpy.da.UpdateCursor(costs_table, [&ldquo;unit_cost&rdquo;, &ldquo;quantity&rdquo;, &ldquo;total_cost&rdquo;]) as curs:
  for row in rows_as_ordered_dicts(curs):</p>

<pre><code>row["total_cost"] = row["unit_cost"] * row["quantity"]

# call .values() to convert back to tuple
# if we didn't use OrderedDict, the values would be in random order.
curs.updateRow( row.values() )
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[arcpy.da Cursors and Readability Part 1]]></title>
    <link href="http://joshwerts.com/blog/2014/08/07/arcpy-dot-da-cursors/"/>
    <updated>2014-08-07T18:36:54-04:00</updated>
    <id>http://joshwerts.com/blog/2014/08/07/arcpy-dot-da-cursors</id>
    <content type="html"><![CDATA[<p>The arcpy.da cursors (ie: arcpy.da.SearchCursor) are far and away better than the regular cursors (ie: arcpy.SearchCursor).  They&rsquo;re more pythonic, incredibly flexible, faster, and allow context management (with).  However, their straight-out-of-the-box-use may be a little hard to read and maintain.</p>

<h3>Fun with Tuples</h3>

<p>arcpy.da cursors return tuples (instead of objects that feel too much like writing ArcObjects).</p>

<h4>Good:</h4>

<p>It&rsquo;s perfectly valid to use tuple indexes to access the fields:</p>

<p>```python
total_cost_by_name = {}
with arcpy.da.SearchCursor(costs_table, [&ldquo;name&rdquo;, &ldquo;unit_cost&rdquo;, &ldquo;quantity&rdquo;]) as curs:</p>

<pre><code>for row in curs:
    total_cost_by_name[row[0]] = row[1] * row[2]
</code></pre>

<p>```</p>

<h4>Better:</h4>

<p>This works fine, but the intent of our calculation is not really clear without some mental mapping.  How about this?
```python
total_cost_by_name = {}
with arcpy.da.SearchCursor(costs_table, [&ldquo;name&rdquo;, &ldquo;unit_cost&rdquo;, &ldquo;quantity&rdquo;]) as curs:</p>

<pre><code>for row in curs:
    name = row[0]
    unit_cost = row[1]
    quantity = row[2]

    total_cost_by_name[name] = unit_cost * quantity
</code></pre>

<p>```</p>

<p>The intent in the calculation is much more clear here, but we&rsquo;ve gained a lot of verbosity that is perhaps unnecessary.</p>

<h4>Best:</h4>

<p>Of course, you could set the variables all on one line <code>name, unit_cost, quantity = row[0], row[1], row[2]</code>, but even better would be to take advantage of python&rsquo;s tuple unpacking:  <code>name, unit_cost, quantity = row</code>.  Taking that one step further, why not unpack every tuple as it&rsquo;s iterated over.  Now we have a process that is both concise and highly readable:</p>

<p>```python
total_cost_by_name = {}
with arcpy.da.SearchCursor(costs_table, [&ldquo;name&rdquo;, &ldquo;unit_cost&rdquo;, &ldquo;quantity&rdquo;]) as curs:</p>

<pre><code>for name, unit_cost, quantity in curs:
    total_cost_by_name[name] = unit_cost * quantity
</code></pre>

<p>```</p>

<p>Now what if we want to update a total cost field in the featureclass using an UpdateCursor instead?</p>

<p>```python
with arcpy.da.UpdateCursor(costs_table, [&ldquo;unit_cost&rdquo;, &ldquo;quantity&rdquo;, &ldquo;total_cost&rdquo;]) as curs:</p>

<pre><code>for unit_cost, quantity, total_cost in curs:
    total_cost = unit_cost * quantity
    curs.updateRow( (unit_cost, quantity, total_cost) )
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python: Recursion With Lists]]></title>
    <link href="http://joshwerts.com/blog/2014/06/28/python-recursion-with-lists/"/>
    <updated>2014-06-28T11:58:45-04:00</updated>
    <id>http://joshwerts.com/blog/2014/06/28/python-recursion-with-lists</id>
    <content type="html"><![CDATA[<p>I rarely find use cases for recursion in my every day work, but every once in a while, there&rsquo;s a problem that comes up where I instantly think: &ldquo;Recursion!&rdquo; (typically followed by an equal mix of excitement and dread).</p>

<p>I often try to get away from GIS related programming when I&rsquo;m not at work.  With limited free time, Python&rsquo;s the perfect language to focus on fundamentals without getting bogged down with other concerns.</p>

<p>Recursion is challenging enough already but I find it even more difficult to wrap my head around when the end result is intended to be a list.  I love nested functions (and closure) in Python (as long as it doesn&rsquo;t get out of hand) and think it works well in this case to provide the expected simple interface to a function despite the fact that recursion is being used internally.</p>

<p>Most of the code I write for work is proprietary and can&rsquo;t be posted here, so here&rsquo;s a classic problem I&rsquo;ve been playing around with simply for learning purposes.</p>

<h4>Code:</h4>

<p>```python
def prime_factors(x):</p>

<pre><code>""" returns all prime factors of x 
ex:  prime_factors(21) = [3,7]
ex:  prime_factors(24) = [2,2,2,3]
"""

def get_first_prime(y):
    """ returns first prime of y """
    # 0 and 1 are not prime, start with 2
    i = 2 

    while i &lt;= y:
        if y % i == 0:
            return i
        i += 1

def get_primes(y, primes):
    """ Recursively appends primes of y
        ex:  prime_factors(24) = [2,2,2,3]

        24
       /  \
      2    12
          /  \
         2    6
             / \
            2   3

    Appends end nodes of tree as it recurses down.
    """
    first_prime = get_first_prime(y)
    primes.append(first_prime)

    if y == first_prime:
        return

    else:
        # Number is not prime and can be divided further.
        # Divide by the first prime (left node) 
        # to get the next test value (right node)
        get_primes(y / first_prime, primes)


primes = []
if x &gt;= 2:
    get_primes(x, primes)

return primes
</code></pre>

<p>```</p>

<h4>Usage:</h4>

<p>```python</p>

<blockquote><blockquote><blockquote><p>prime_factors(24)
[2, 2, 2, 3]
prime_factors(13595)
[5, 7, 13, 29]
prime_factors(23049820394)
[2, 89, 139, 181, 5147]
```</p></blockquote></blockquote></blockquote>

<p>The list <code>primes</code> is passed by reference into the recursive function and simply appended to throughout the operation to keep track of the values.  There is no actual return value from the function.</p>

<p>This could be difficult to follow if the end user used: <code>get_primes(y, primes) -&gt; void</code> directly but since it&rsquo;s wrapped in a simpler interface:  <code>prime_factors(x) -&gt; primes</code>, the end result is a returned list as expected.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arcpy: Reorder Fields]]></title>
    <link href="http://joshwerts.com/blog/2014/04/17/arcpy-reorder-fields/"/>
    <updated>2014-04-17T17:34:45-04:00</updated>
    <id>http://joshwerts.com/blog/2014/04/17/arcpy-reorder-fields</id>
    <content type="html"><![CDATA[<p>Here&rsquo;s another handy function for re-ordering fields in a feature class.  Like the <code>rename_fields</code> function previously posted, it recreates the existing field mappings and modifies as necessary.  The output is a new feature class with fields in the order specified.</p>

<p>The only caveat is that required fields always get pushed to the front (so the featureclass will start with OBJECTID, Shape, rest of fields&hellip;).  After required fields are out of the way, the rest of the fields are added in the order specified in the <code>field_order</code> list.  If any fields are missing, they are added to the end of the feature class.</p>

<p>```python
import arcpy</p>

<p>def reorder_fields(table, out_table, field_order, add_missing=True):</p>

<pre><code>""" 
Reorders fields in input featureclass/table
:table:         input table (fc, table, layer, etc)
:out_table:     output table (fc, table, layer, etc)
:field_order:   order of fields (objectid, shape not necessary)
:add_missing:   add missing fields to end if True (leave out if False)
-&gt; path to output table
"""
existing_fields = arcpy.ListFields(table)
existing_field_names = [field.name for field in existing_fields]

existing_mapping = arcpy.FieldMappings()
existing_mapping.addTable(table)

new_mapping = arcpy.FieldMappings()

def add_mapping(field_name):
    mapping_index = existing_mapping.findFieldMapIndex(field_name)

    # required fields (OBJECTID, etc) will not be in existing mappings
    # they are added automatically
    if mapping_index != -1:
        field_map = existing_mapping.fieldMappings[mapping_index]
        new_mapping.addFieldMap(field_map)

# add user fields from field_order
for field_name in field_order:
    if field_name not in existing_field_names:
        raise Exception("Field: {0} not in {1}".format(field_name, table))

    add_mapping(field_name)

# add missing fields at end
if add_missing:
    missing_fields = [f for f in existing_field_names if f not in field_order]
    for field_name in missing_fields:
        add_mapping(field_name)

# use merge with single input just to use new field_mappings
arcpy.Merge_management(table, out_table, new_mapping)
return out_table
</code></pre>

<p>```</p>

<p>Usage:
<code>python
new_field_order = ["field2", "field3", "field1"]
reorder_fields(in_fc, out_fc, new_field_order)
</code></p>

<p>I&rsquo;ve tested this in 10.1.1+ &ndash; it may work in 10.0 as well and should work with any license level.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arcpy: Rename Fields]]></title>
    <link href="http://joshwerts.com/blog/2014/04/01/arcpy-rename-fields/"/>
    <updated>2014-04-01T07:43:15-04:00</updated>
    <id>http://joshwerts.com/blog/2014/04/01/arcpy-rename-fields</id>
    <content type="html"><![CDATA[<p>In ArcMap 10.2.1, esri finally added a tool to allow renaming of fields (Data Management &ndash;> Alter Field).</p>

<p><img class="center" src="/images/arcpy_rename_field_alter_field_tool.PNG" width="350" height="350" title="&lsquo;alter field tool&rsquo; &lsquo;images&rsquo;" ></p>

<p>This works well for a single field, but you may need something different if:</p>

<ul>
<li>you&rsquo;re still on 10.0/10.1,</li>
<li>you want to rename several fields at once,</li>
<li>you would prefer not to rename the fields in-place,</li>
<li>you need to rename fields in a source unsupported by the Alter Field tool (hint: shapefiles).</li>
</ul>


<p>Here&rsquo;s a great function for renaming fields (and maintaining their order).  It can be used in the python console.</p>

<p>```python
def rename_fields(table, out_table, new_name_by_old_name):</p>

<pre><code>""" Renames specified fields in input feature class/table 
:table:                 input table (fc, table, layer, etc)
:out_table:             output table (fc, table, layer, etc)
:new_name_by_old_name:  {'old_field_name':'new_field_name',...}
-&gt;  out_table
"""
existing_field_names = [field.name for field in arcpy.ListFields(table)]

field_mappings = arcpy.FieldMappings()
field_mappings.addTable(table)

for old_field_name, new_field_name in new_name_by_old_name.iteritems():
    if old_field_name not in existing_field_names:
        message = "Field: {0} not in {1}".format(old_field_name, table)
        raise Exception(message)

    mapping_index = field_mappings.findFieldMapIndex(old_field_name)
    field_map = field_mappings.fieldMappings[mapping_index]
    output_field = field_map.outputField
    output_field.name = new_field_name
    output_field.aliasName = new_field_name
    field_map.outputField = output_field
    field_mappings.replaceFieldMap(mapping_index, field_map)

# use merge with single input just to use new field_mappings
arcpy.Merge_management(table, out_table, field_mappings)
return out_table
</code></pre>

<p>```</p>

<p>The function accepts the input feature class, path to output, and a dictionary mapping the old names to the new names:</p>

<p>Usage:
```python</p>

<h1>does need need to include all fields, only those you want to rename</h1>

<p>new_name_by_old_name = { &lsquo;old_name_1&rsquo;:&lsquo;new_name_1&rsquo;,</p>

<pre><code>                     'old_name_2':'new_name_2' }
</code></pre>

<p>rename_fields(in_fc, renamed_fc, new_name_by_old_name)
```</p>

<p>This works by duplicating the arcpy.FieldMappings object from the existing feature class, renaming the fields within the mapping based on the input, and then calling a function that will apply that mapping.  Merge with a single input gets the job done.  Using the field mappings is a nice trick for efficiently managing fields.</p>
]]></content>
  </entry>
  
</feed>
